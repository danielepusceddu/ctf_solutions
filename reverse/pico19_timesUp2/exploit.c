#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "tinyexpr.h"

#define die(e) do { fprintf(stderr, "%s\n", e); exit(EXIT_FAILURE); } while (0);

int main() {
  int child2parent[2];
  int parent2child[2];
  pid_t pid;

  /* Just some error checking */
  if (pipe(child2parent) == -1)
    die("Failue on 1st pipe");

  if (pipe(parent2child) == -1)
      die("Failure on 2nd pipe");

  if ((pid = fork()) == -1)
    die("Failure on fork");

  if(pid == 0) { //If we're the Child
    //Setting up the pipes
    //For more information on pipes: http://tldp.org/LDP/lpg/node11.html
    dup2 (child2parent[1], STDOUT_FILENO);
    dup2(parent2child[0], STDIN_FILENO);

    close(child2parent[0]);
    close(child2parent[1]);
    close(parent2child[0]);
    close(parent2child[1]);
    
    //Executing the challenge
    execl("./times-up-again", "times-up-again", NULL);

    //exec should not return. If it does, something bad happened
    die("Failure on exec");

  } else { //If we're the Parent
    char line[1000];
    char* expression;

    close(child2parent[1]);
    close(parent2child[0]);

    //Obtaining the expression string
    int nbytes = read(child2parent[0], line, sizeof(line));
    line[nbytes] = 0;

    expression = line + 11; //Skip the initial "Challenge: "
    for(int i = 0; i < nbytes - 11; i++){
        if(expression[i] == '\n'){
            expression[i] = '\0'; //Terminate the string at the first newline
            break;
        }
    }

    printf("Expression: %s\n", expression);

    //Solve the expression
    int err;
    long result = te_interp(expression, &err);
    int inputLen = sprintf(line, "%ld\n", result);

    //Send the solution to child
    write(parent2child[1], line, strlen(line)); 

    //Retrieve the response, which should contain the flag.
    nbytes = read(child2parent[0], line, sizeof(line));
    line[nbytes] = 0;
    printf("Response: %s\n", line);  //picoCTF{Hasten. Hurry. Ferrociously Speedy. #3b0e50c7}
    //wait(NULL);

  }
  return 0;
}
